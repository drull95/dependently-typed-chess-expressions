-- open import Data.Sum using (_‚äé_; inj‚ÇÅ; inj‚ÇÇ)
open import Function
open import Data.Product using (_√ó_; _,_; proj‚ÇÅ; proj‚ÇÇ)
open import Data.Maybe using (Maybe; nothing; just)
open import Data.Nat as ‚Ñï using (‚Ñï; suc; zero; _‚à∏_; _‚âü_; _+_)
open import Data.List using (List; []; [_]; _++_; _‚à∑_; map; zip; any; all; filter)
open import Data.Bool using (Bool; true; false; if_then_else_; _‚àß_; _‚à®_; T; not)
open import Relation.Binary.PropositionalEquality using (refl; _‚â°_)
open import Relation.Nullary using (¬¨_; yes; no)
open import Data.Empty using (‚ä•)
open import Data.Unit
open import Data.List.All as All using (All)
open import Data.List.Any as Any using (Any)

-- | utilities

_==_ : ‚Ñï ‚Üí ‚Ñï ‚Üí Bool
m == n with m ‚Ñï.‚âü n
... | yes _ = true
... | no  _ = false

_ùîπ=_ : Bool ‚Üí Bool ‚Üí Bool
_ùîπ=_ true true = true
_ùîπ=_ false false = true
_ùîπ=_ _     _     = false

-- indexing list with a eq function
!! : {A B : Set} ‚Üí (A ‚Üí A ‚Üí Bool) ‚Üí List (A √ó B) ‚Üí A ‚Üí Maybe B
!! _ [] p = nothing
!! eq ((a , b) ‚à∑ as) p with eq a p
...| true = just b
...| _ = !! eq as p

_>_ : ‚Ñï ‚Üí ‚Ñï ‚Üí Bool
zero > zero = false
zero > suc _ = false
suc _ > zero = true
suc m > suc n = m > n

_<_ : ‚Ñï ‚Üí ‚Ñï ‚Üí Bool
zero < zero = false
zero < suc _ = true
suc _ < zero = false
suc a < suc b = a < b

-- | Membership

data _‚àà_ {A : Set}(x : A) : List A ‚Üí Set where
  first : ‚àÄ {xs}   ‚Üí x ‚àà x ‚à∑ xs
  next  : ‚àÄ {y xs} ‚Üí x ‚àà xs ‚Üí x ‚àà y ‚à∑ xs

infix 4 _‚àà_

-- | Color

data Color : Set where
  white : Color
  black : Color

-- | Squares

data File : Set where
  A : File
  B : File
  C : File
  D : File
  E : File
  F : File
  G : File
  H : File

data Rank : Set where
  #1 : Rank
  #2 : Rank
  #3 : Rank
  #4 : Rank
  #5 : Rank
  #6 : Rank
  #7 : Rank
  #8 : Rank

Square = File √ó Rank

-- the king cannot castle if it passes through a square that would
-- put it in check

fileEq : File ‚Üí File ‚Üí Bool
fileEq A A = true
fileEq B B = true
fileEq C C = true
fileEq D D = true
fileEq E E = true
fileEq F F = true
fileEq G G = true
fileEq H H = true
fileEq _ _ = false

rankEq : Rank ‚Üí Rank ‚Üí Bool
rankEq #1 #1 = true
rankEq #2 #2 = true
rankEq #3 #3 = true
rankEq #4 #4 = true
rankEq #5 #5 = true
rankEq #6 #6 = true
rankEq #7 #7 = true
rankEq #8 #8 = true
rankEq _  _  = false

rankIs : Rank ‚Üí Square ‚Üí Bool
rankIs r (a , b) = rankEq r b

sqEq : Maybe Square ‚Üí Square ‚Üí Bool
sqEq (just (a , b)) (c , d) = fileEq a c ‚àß rankEq b d
sqEq _ _ = false

-- i tried to avoid casting to naturals but some things are just easier with it
fileTo‚Ñï : File ‚Üí ‚Ñï
fileTo‚Ñï A = 1
fileTo‚Ñï B = 2
fileTo‚Ñï C = 3
fileTo‚Ñï D = 4
fileTo‚Ñï E = 5
fileTo‚Ñï F = 6
fileTo‚Ñï G = 7
fileTo‚Ñï H = 8

‚ÑïtoFile : ‚Ñï ‚Üí File
‚ÑïtoFile zero = A
‚ÑïtoFile 1 = A
‚ÑïtoFile 2 = B
‚ÑïtoFile 3 = C
‚ÑïtoFile 4 = D
‚ÑïtoFile 5 = E
‚ÑïtoFile 6 = F
‚ÑïtoFile 7 = G
‚ÑïtoFile 8 = H
‚ÑïtoFile _ = H

rankTo‚Ñï : Rank ‚Üí ‚Ñï
rankTo‚Ñï #1 = 1
rankTo‚Ñï #2 = 2
rankTo‚Ñï #3 = 3
rankTo‚Ñï #4 = 4
rankTo‚Ñï #5 = 5
rankTo‚Ñï #6 = 6
rankTo‚Ñï #7 = 7
rankTo‚Ñï #8 = 8

‚ÑïtoRank : ‚Ñï ‚Üí Rank
‚ÑïtoRank 1 = #1
‚ÑïtoRank 2 = #2
‚ÑïtoRank 3 = #3
‚ÑïtoRank 4 = #4
‚ÑïtoRank 5 = #5
‚ÑïtoRank 6 = #6
‚ÑïtoRank 7 = #7
‚ÑïtoRank 8 = #8
‚ÑïtoRank _ = #8

file : Square ‚Üí ‚Ñï
file (a , b) = fileTo‚Ñï a

rank : Square ‚Üí ‚Ñï
rank (_ , b) = rankTo‚Ñï b

isValid : ‚Ñï √ó ‚Ñï ‚Üí Bool
isValid (a , b) =
  a > 0 ‚àß a < 9 ‚àß b > 0 ‚àß b < 9
  
-- enumerating the squares around a square. used for checking if the
-- king is in checkmate
sqsAround : Square ‚Üí List Square
sqsAround (a' , b') =
  let a = fileTo‚Ñï a'
      b = rankTo‚Ñï b'
      sqs = (a + 1 , b) ‚à∑ (a ‚à∏ 1 , b) ‚à∑ (a , b + 1) ‚à∑ (a , b ‚à∏ 1) ‚à∑ []
  in map (Œª{ (c , d) ‚Üí ‚ÑïtoFile c , ‚ÑïtoRank d })
         (filter isValid sqs)

-- | is this square relative to that one or that one to this?
-- | how many columns or rows away is a square

columnsAway : Square ‚Üí Square ‚Üí ‚Ñï
columnsAway (a , _) (b , _) =
  let a' = fileTo‚Ñï a
      b' = fileTo‚Ñï b
  in if a' > b' then a' ‚à∏ b'
                else b' ‚à∏ a'
                 
aa = columnsAway (A , #1) (B , #1) 
ab = columnsAway (A , #1) (A , #1)
ac = columnsAway (A , #1) (H , #1)

rowsAway : Square ‚Üí Square ‚Üí ‚Ñï
rowsAway (_ , a') (_ , b') =
  let a = rankTo‚Ñï a'
      b = rankTo‚Ñï b'
  in if a > b then a ‚à∏ b
           else b ‚à∏ a

-- | helpers for enumerating squares *between* squares

enumBetween‚Ñï‚ÇÅ : ‚Ñï ‚Üí ‚Ñï ‚Üí List ‚Ñï
enumBetween‚Ñï‚ÇÅ a zero    = []
enumBetween‚Ñï‚ÇÅ a (suc b) =
   if a == b then []
   else b ‚à∑ enumBetween‚Ñï‚ÇÅ a b

enumBetween‚Ñï : ‚Ñï ‚Üí ‚Ñï ‚Üí List ‚Ñï
enumBetween‚Ñï a b =
  if a > b
  then enumBetween‚Ñï‚ÇÅ b a
  else enumBetween‚Ñï‚ÇÅ a b

bc : enumBetween‚Ñï 4 8 ‚â° (7 ‚à∑ 6 ‚à∑ 5 ‚à∑ [])
bc = refl
be = enumBetween‚Ñï 8 4
bd = enumBetween‚Ñï  1 4
bf = enumBetween‚Ñï 4 1

enumBetweenRanks : Rank ‚Üí Rank ‚Üí List Rank
enumBetweenRanks a b =
  let a' = rankTo‚Ñï a
      b' = rankTo‚Ñï b
  in map ‚ÑïtoRank (enumBetween‚Ñï a' b')

enumBetweenFiles : File ‚Üí File ‚Üí List File
enumBetweenFiles a b =
  let a' = fileTo‚Ñï a
      b' = fileTo‚Ñï b
  in map ‚ÑïtoFile (enumBetween‚Ñï a' b')

-- | is it straight, diagonal or horsey

isStraight : Square ‚Üí Square ‚Üí Bool
isStraight (a , b) (c , d) = fileEq a c ‚à® rankEq b d

isDiagonal : Square ‚Üí Square ‚Üí Bool
isDiagonal a b =
  (columnsAway a b > 0 ‚àß rowsAway a b > 0) ‚àß
  (columnsAway a b == rowsAway a b)

isHorseyMove : Square ‚Üí Square ‚Üí Bool
isHorseyMove a b = 
  (columnsAway a b == 2 ‚àß rowsAway a b == 1) ‚à®
  (columnsAway a b == 1 ‚àß rowsAway a b == 2)

oneSquareAway : Square ‚Üí Square ‚Üí Bool
oneSquareAway a b = 
  (columnsAway a b == 1 ‚àß rowsAway a b == 0) ‚à®
  (columnsAway a b == 0 ‚àß rowsAway a b == 1) ‚à®
  (columnsAway a b == 1 ‚àß rowsAway a b == 1)

enumStraight : (sq sq‚ÇÅ : Square) ‚Üí T (isStraight sq sq‚ÇÅ) ‚Üí List Square
enumStraight (a , b) (c , d) _ =
  if fileEq a c -- we're in a column
  then map (a ,_) (enumBetweenRanks b d)
  else map (_, b) (enumBetweenFiles a c)

-- | "unit tests" for enumSquaresStraight

ba : List Square
ba = enumStraight (A , #4) (A , #8) tt

bb : List Square
bb = enumStraight (A , #4) (A , #1) tt 

bg : List Square
bg = enumStraight (A , #5) (D , #5) tt

-- | enumerating squares diagonally

enumDiagonal : (sq sq‚ÇÅ : Square) ‚Üí T (isDiagonal sq sq‚ÇÅ) ‚Üí List Square
enumDiagonal (a , b) (c , d) _ = 
  let rs = enumBetweenRanks b d
      fs = enumBetweenFiles a c
  in zip fs rs

oneFileHigher : Square ‚Üí Square ‚Üí Bool
oneFileHigher s q = (file s ‚à∏ file q) == 1

oneFileLower : Square ‚Üí Square ‚Üí Bool
oneFileLower s q = (file q ‚à∏ file s) == 1
    
oneRankHigher : Square ‚Üí Square ‚Üí Bool
oneRankHigher s q = (rank s ‚à∏ rank q) == 1

oneRankLower : Square ‚Üí Square ‚Üí Bool
oneRankLower s q = (rank q ‚à∏ rank s) == 1

sameFile : Square ‚Üí Square ‚Üí Bool
sameFile (a , b) (c , d) = fileEq a c

sameRank : Square ‚Üí Square ‚Üí Bool
sameRank (a , b) (c , d) = rankEq b d

twoFilesLower : Square ‚Üí Square ‚Üí Bool
twoFilesLower s q = (file q ‚à∏ file s) == 2

twoFilesHigher : Square ‚Üí Square ‚Üí Bool
twoFilesHigher s q = (file s ‚à∏ file q) == 2

twoRanksLower : Square ‚Üí Square ‚Üí Bool
twoRanksLower s q = (rank q ‚à∏ rank s) == 2

twoRanksHigher : Square ‚Üí Square ‚Üí Bool
twoRanksHigher s q = (rank s ‚à∏ rank q) == 2

north : Square ‚Üí Square ‚Üí Bool
north s q = sameFile s q ‚àß oneRankHigher s q

east : Square ‚Üí Square ‚Üí Bool
east s q = sameRank s q ‚àß oneFileHigher s q

south : Square ‚Üí Square ‚Üí Bool
south s q = sameFile s q ‚àß oneRankLower s q

west : Square ‚Üí Square ‚Üí Bool
west s q = sameRank s q ‚àß oneFileLower s q

northeast : Square ‚Üí Square ‚Üí Bool
northeast s q = oneFileHigher s q ‚àß oneRankHigher s q

northwest : Square ‚Üí Square ‚Üí Bool
northwest s q = oneFileLower s q ‚àß oneRankHigher s q

southeast : Square ‚Üí Square ‚Üí Bool
southeast s q = oneFileHigher s q ‚àß oneRankLower s q

southwest : Square ‚Üí Square ‚Üí Bool
southwest s q = oneFileLower s q ‚àß oneRankLower s q

atTopOrBottom : Square ‚Üí Bool
atTopOrBottom (_ , #1) = true
atTopOrBottom (_ , #8) = true
atTopOrBottom _ = false

-- | is a square relative to another or is that one relative to this one?
    
-- | Pieces

-- king's rook or queens, kings knight or queens , etc
data Which : Set where
  k : Which
  q : Which
 
data WhichPawn : Set where
  p1 : WhichPawn
  p2 : WhichPawn
  p3 : WhichPawn
  p4 : WhichPawn
  p5 : WhichPawn
  p6 : WhichPawn
  p7 : WhichPawn
  p8 : WhichPawn

data Piece : Set where
  king   : Piece
  queen  : Piece
  bishop : Which ‚Üí Piece
  knight : Which ‚Üí Piece
  rook   : Which ‚Üí Piece
  pawn   : WhichPawn ‚Üí Piece

pieceEq : Piece ‚Üí Piece ‚Üí Bool
pieceEq king king = true
pieceEq queen queen = true
pieceEq (bishop k)  (bishop k) = true
pieceEq (bishop q) (bishop q) = true
pieceEq (knight k)  (knight k) = true
pieceEq (knight q) (knight q) = true
pieceEq (rook   k)  (rook k) = true
pieceEq (rook   q) (rook q) = true
pieceEq (pawn p1) (pawn p1) = true
pieceEq (pawn p2) (pawn p2) = true
pieceEq (pawn p3) (pawn p3) = true
pieceEq (pawn p4) (pawn p4) = true
pieceEq (pawn p5) (pawn p5) = true
pieceEq (pawn p6) (pawn p6) = true
pieceEq (pawn p7) (pawn p7) = true
pieceEq (pawn p8) (pawn p8) = true
pieceEq _     _  = false

whichPawnEq : WhichPawn ‚Üí WhichPawn ‚Üí Bool
whichPawnEq p1 p1 = true
whichPawnEq p2 p2 = true
whichPawnEq p3 p3 = true
whichPawnEq p4 p4 = true
whichPawnEq p5 p5 = true
whichPawnEq p6 p6 = true
whichPawnEq p7 p7 = true
whichPawnEq p8 p8 = true
whichPawnEq _  _  = false

-- | Side, information about the pieces of each color

record Side : Set where
  field
    pieces       : List (Piece √ó Maybe Square)
    kMoved       : Bool -- did the king move?
    qrMoved      : Bool -- either of the rooks moved?
    krMoved      : Bool
    pawnHasMoved : List (WhichPawn √ó Bool) -- can the pawn en passant?
    pawnPromotes : List (WhichPawn √ó Maybe Piece) -- which piece are you now?
    
open Side

-- | BoardArrangement

record BoardArrangement : Set where
  field
    whiteSide : Side
    blackSide : Side
    whosTurn : Color

open BoardArrangement

lcastlePassesThroughSquare : BoardArrangement ‚Üí Square
lcastlePassesThroughSquare b =
  case whosTurn b of
  Œª{ white ‚Üí (C , #1)
   ; black ‚Üí (C , #8)
   }

scastlePassesThroughSquare : BoardArrangement ‚Üí Square
scastlePassesThroughSquare b =
  case whosTurn b of
  Œª{ white ‚Üí (G , #1)
   ; black ‚Üí (G , #8)
   }

-- | all of the pieces
allPieces : BoardArrangement ‚Üí List (Piece √ó Maybe Square)
allPieces record { whiteSide = w
                 ; blackSide = b
                 } =
  pieces w ++ pieces b

turnSide : BoardArrangement ‚Üí Side
turnSide b =
  case whosTurn b of
  Œª{ white ‚Üí whiteSide b
   ; black ‚Üí blackSide b
   }
   
-- | finding squares

sqOf : Piece √ó Maybe Square ‚Üí Maybe Square
sqOf (a , b) = b

sqsOfAllPieces = map sqOf ‚àò allPieces

sqOfPiece : BoardArrangement ‚Üí Piece ‚Üí Maybe Square
sqOfPiece b p =
  let wps = pieces (whiteSide b)
      bps = pieces (blackSide b)
  in case whosTurn b of
  Œª{ white ‚Üí case !! pieceEq wps p of
              Œª{ (just sq) ‚Üí sq
               ; nothing ‚Üí nothing
               }
   ; black ‚Üí case !! pieceEq bps p of
              Œª{ (just sq) ‚Üí sq
               ; nothing ‚Üí nothing
               }
   }

sqOfOpponentPiece : BoardArrangement ‚Üí Piece ‚Üí Maybe Square
sqOfOpponentPiece b p =
  let wps = pieces (whiteSide b)
      bps = pieces (blackSide b)
  in case whosTurn b of
  Œª{ white ‚Üí case !! pieceEq bps p of
              Œª{ (just sq) ‚Üí sq
               ; nothing ‚Üí nothing
               }
   ; black ‚Üí case !! pieceEq wps p of
              Œª{ (just sq) ‚Üí sq
               ; nothing ‚Üí nothing
               }
   }

sqsOfOpponentPieces : BoardArrangement ‚Üí List (Maybe Square)
sqsOfOpponentPieces b = 
  case whosTurn b of
  Œª{ white ‚Üí map sqOf (pieces (blackSide b))
   ; black ‚Üí map sqOf (pieces (whiteSide b))
   }
 
sqsOfFriendlyPieces : BoardArrangement ‚Üí List (Maybe Square)
sqsOfFriendlyPieces b =
  case whosTurn b of
  Œª{ white ‚Üí map sqOf (pieces (whiteSide b))
   ; black ‚Üí map sqOf (pieces (blackSide b))
   }

-- | altering pieces 

updatePiece : List (Piece √ó Maybe Square) ‚Üí Piece ‚Üí Maybe Square ‚Üí List (Piece √ó Maybe Square)
updatePiece [] p sq = []
updatePiece ((x , y) ‚à∑ xs) p sq with pieceEq x p
...| true = (x , sq) ‚à∑ xs
...| false = (x , y) ‚à∑ updatePiece xs p sq

updateSide : Side ‚Üí List (Piece √ó Maybe Square) ‚Üí Side
updateSide s l = record s {pieces = l}

mvPiece : BoardArrangement ‚Üí Piece ‚Üí Square ‚Üí BoardArrangement
mvPiece b p sq =
  let wps = pieces (whiteSide b)
      bps = pieces (blackSide b)
  in case whosTurn b of
     Œª{ white ‚Üí record b {
         whiteSide =
           updateSide (whiteSide b) (updatePiece wps p (just sq)) }
      ; black ‚Üí record b {
          blackSide =
            updateSide (blackSide b) (updatePiece bps p (just sq)) }
      }
   
removePiece : BoardArrangement ‚Üí Piece ‚Üí BoardArrangement
removePiece b p =
  let wps = pieces (whiteSide b)
      bps = pieces (blackSide b)
  in case whosTurn b of
     Œª{ white ‚Üí record b {
          blackSide =
            updateSide (blackSide b) (updatePiece bps p nothing)}
      ; black ‚Üí record b {
          whiteSide =
            updateSide (whiteSide b) (updatePiece wps p nothing)}
      }

-- | helper for whoHasSquare

!!! : {A B : Set} ‚Üí (Maybe B ‚Üí B ‚Üí Bool) ‚Üí List (A √ó Maybe B) ‚Üí B ‚Üí Maybe A
!!! eq [] b = nothing
!!! eq ((y , x) ‚à∑ xs) b with eq x b
...| true = just y 
...| false = !!! eq xs b

-- | helper for capturePiece

whoHasSquare : BoardArrangement ‚Üí Square ‚Üí Maybe Piece
whoHasSquare b s =
  let wps = pieces (whiteSide b)
      bps = pieces (blackSide b)
  in case whosTurn b of
     Œª{ white ‚Üí !!! sqEq wps s
      ; black ‚Üí !!! sqEq bps s
      }
   
capturePiece : BoardArrangement ‚Üí Piece ‚Üí Square ‚Üí BoardArrangement
capturePiece b p sq =
  let b' = mvPiece b p sq
  in case whoHasSquare b sq of
     Œª{ (just p) ‚Üí removePiece b' p
      ; nothing ‚Üí b'
      }

-- | short and long castles

lcastle : BoardArrangement ‚Üí BoardArrangement
lcastle b =
  case whosTurn b of
  Œª{ white ‚Üí
       let b' = mvPiece b king (C , #1)
       in mvPiece b' (rook q) (D , #1)
   ; black ‚Üí 
       let b' = mvPiece b king (C , #8)
       in mvPiece b' (rook q) (D , #8)
   }

scastle : BoardArrangement ‚Üí BoardArrangement
scastle b = 
  case whosTurn b of
  Œª{ white ‚Üí
       let b' = mvPiece b king (G , #1)
       in mvPiece b' (rook k) (F , #1)
   ; black ‚Üí
       let b' = mvPiece b king (G , #8)
       in mvPiece b' (rook k) (F , #8)
   }

-- | helper for promotePawn‚ÇÅ

setPawn : List (WhichPawn √ó Maybe Piece) ‚Üí WhichPawn ‚Üí Piece ‚Üí List (WhichPawn √ó Maybe Piece)
setPawn [] _ _ = []
setPawn ((ws , a) ‚à∑ pcs) wp p with whichPawnEq ws wp
...| true = (ws , just p) ‚à∑ pcs
...| false = (ws , a) ‚à∑ setPawn pcs wp p

-- | helper for promotePawn

promotePawn‚ÇÅ : Side ‚Üí WhichPawn ‚Üí Piece ‚Üí Side
promotePawn‚ÇÅ s wp p =
  let proms = pawnPromotes s
  in record s { pawnPromotes = setPawn proms wp p }
  
promotePawn : BoardArrangement ‚Üí WhichPawn ‚Üí Piece ‚Üí  BoardArrangement
promotePawn b wp p =
  let ws = whiteSide b
      bs = blackSide b
  in case whosTurn b of
     Œª{ white ‚Üí 
          record b { whiteSide = promotePawn‚ÇÅ ws wp p }
      ; black ‚Üí
          record b { blackSide = promotePawn‚ÇÅ bs wp p }
      }

pawnMoved‚ÇÅ : WhichPawn ‚Üí List (WhichPawn √ó Bool) ‚Üí Bool
pawnMoved‚ÇÅ wp [] = false
pawnMoved‚ÇÅ wp ((wp‚ÇÅ , b) ‚à∑ cs) with whichPawnEq wp wp‚ÇÅ
...| true = b
...| false = pawnMoved‚ÇÅ wp cs

pawnMoved : BoardArrangement ‚Üí WhichPawn ‚Üí Bool
pawnMoved b wp =
  case whosTurn b of
  Œª{ white ‚Üí pawnMoved‚ÇÅ wp (pawnHasMoved (whiteSide b))
   ; black ‚Üí pawnMoved‚ÇÅ wp (pawnHasMoved (blackSide b))
   }
   
markPawn‚ÇÅ : WhichPawn ‚Üí List (WhichPawn √ó Bool) ‚Üí List (WhichPawn √ó Bool)
markPawn‚ÇÅ wp [] = []
markPawn‚ÇÅ wp ((wp‚ÇÅ , b) ‚à∑ cs) with whichPawnEq wp wp‚ÇÅ
...| true = (wp , true) ‚à∑ cs
...| false = (wp‚ÇÅ , b) ‚à∑ markPawn‚ÇÅ wp cs

markPawnMoved : WhichPawn ‚Üí BoardArrangement ‚Üí BoardArrangement
markPawnMoved wp b =
  let ws = whiteSide b
      bs = blackSide b
  in case whosTurn b of
     Œª{ white ‚Üí
          record b { whiteSide =
            record ws {
              pawnHasMoved = markPawn‚ÇÅ wp (pawnHasMoved ws)}}
      ; black ‚Üí
          record b { blackSide =
            record bs {
              pawnHasMoved = markPawn‚ÇÅ wp (pawnHasMoved bs)}}
      }

movePawn : BoardArrangement ‚Üí WhichPawn ‚Üí Square ‚Üí BoardArrangement
movePawn b wp s =
  markPawnMoved wp (mvPiece b (pawn wp) s)

capturePawn : BoardArrangement ‚Üí WhichPawn ‚Üí Square ‚Üí BoardArrangement
capturePawn b wp s =
  markPawnMoved wp (capturePiece b (pawn wp) s)

doEnPassant : BoardArrangement ‚Üí WhichPawn ‚Üí Square ‚Üí Square ‚Üí BoardArrangement
doEnPassant b wp sq sq‚ÇÅ = 
  let b' = mvPiece b (pawn wp) sq
  in case whoHasSquare b sq‚ÇÅ of -- cheating
     Œª{ (just (pawn p)) ‚Üí removePiece b' (pawn p)
      ; _ ‚Üí b'
      }

markKingMoved : BoardArrangement ‚Üí BoardArrangement 
markKingMoved b =
  let ws = whiteSide b
      bs = blackSide b
  in case whosTurn b of
     Œª{ white ‚Üí record b { whiteSide = record ws { kMoved = true }}
      ; black ‚Üí record b { blackSide = record bs { kMoved = true }}
      }

markRookMoved : Which ‚Üí BoardArrangement ‚Üí BoardArrangement
markRookMoved w b =
  let ws = whiteSide b
      bs = blackSide b
  in case w , whosTurn b of
     Œª{ (q , white) ‚Üí
           record b {whiteSide = record ws { qrMoved = true }}
      ; (q , black) ‚Üí
           record b {blackSide = record bs { qrMoved = true }}
      ; (k , white) ‚Üí
           record b {whiteSide = record ws { krMoved = true }}
      ; (k , black) ‚Üí
           record b {blackSide = record bs { krMoved = true }}
      }
  
data IsPromoted : WhichPawn ‚Üí Piece ‚Üí WhichPawn √ó Maybe Piece ‚Üí Set where
  isPromoted : ‚àÄ{wp p entry}
    ‚Üí wp ‚â° proj‚ÇÅ entry
    ‚Üí just p ‚â° proj‚ÇÇ entry
    ‚Üí IsPromoted wp p entry
    
data Promoted : BoardArrangement ‚Üí WhichPawn ‚Üí Piece ‚Üí Set where
  isPromW : ‚àÄ{b wp p}
    ‚Üí whosTurn b ‚â° white
    ‚Üí Any (IsPromoted wp p) (pawnPromotes (whiteSide b))
    ‚Üí Promoted b wp p
    
  isPromB : ‚àÄ{b wp p}
    ‚Üí whosTurn b ‚â° black
    ‚Üí Any (IsPromoted wp p) (pawnPromotes (blackSide b))
    ‚Üí Promoted b wp p

data IsNotProm : WhichPawn ‚Üí WhichPawn √ó Maybe Piece ‚Üí Set where
  isNotProm : ‚àÄ{wp entry}
    ‚Üí wp ‚â° proj‚ÇÅ entry
    ‚Üí nothing ‚â° proj‚ÇÇ entry
    ‚Üí IsNotProm wp entry

data NotPromoted : BoardArrangement ‚Üí WhichPawn ‚Üí Set where
  isNotPromotedW : ‚àÄ{b wp}
    ‚Üí whosTurn b ‚â° white
    ‚Üí Any (IsNotProm wp) (pawnPromotes (whiteSide b))
    ‚Üí NotPromoted b wp

  isNotPromotedB : ‚àÄ{b wp}
    ‚Üí whosTurn b ‚â° black
    ‚Üí Any (IsNotProm wp) (pawnPromotes (blackSide b))
    ‚Üí NotPromoted b wp

-- the movement of pawns

oneSquareForward : BoardArrangement ‚Üí Square ‚Üí Square ‚Üí Bool
oneSquareForward b s sq =
  case whosTurn b of
  Œª{ white ‚Üí sameFile s sq ‚àß oneRankHigher s sq
   ; black ‚Üí sameFile s sq ‚àß oneRankLower s sq
   }

isCaptureMove : BoardArrangement ‚Üí Square ‚Üí Square ‚Üí Bool
isCaptureMove b s sq =
  case whosTurn b of
  Œª{ white ‚Üí northeast s sq ‚à® northwest s sq
   ; black ‚Üí southeast s sq ‚à® southwest s sq
   }


-- | the occupation of little bits of land

data Occupied : BoardArrangement ‚Üí Square ‚Üí Set where
  occupied : ‚àÄ{sq b}
    ‚Üí just sq ‚àà sqsOfAllPieces b ‚Üí Occupied b sq

data OccupiedWith : BoardArrangement ‚Üí Piece ‚Üí Square ‚Üí Set where
  occWith : ‚àÄ{b p sq}
    ‚Üí just sq ‚â° sqOfPiece b p
    ‚Üí OccupiedWith b p sq

data OccupiedWithOpponentPiece : BoardArrangement ‚Üí Piece ‚Üí Square ‚Üí Set where
  occWithOpponentPiece : ‚àÄ{b p sq}
    ‚Üí just sq ‚â° sqOfOpponentPiece b p
    ‚Üí OccupiedWithOpponentPiece b p sq
    
data OccupiedByOpponent : BoardArrangement ‚Üí Square ‚Üí Set where
  occOpponent : ‚àÄ{b sq}
    ‚Üí just sq ‚àà sqsOfOpponentPieces b
    ‚Üí OccupiedByOpponent b sq

data OccupiedByFriendly : BoardArrangement ‚Üí Square ‚Üí Set where
  occFriendly : ‚àÄ{b sq}
    ‚Üí just sq ‚àà sqsOfFriendlyPieces b
    ‚Üí OccupiedByFriendly b sq
    
data NotOccupied : BoardArrangement ‚Üí List Square ‚Üí Set where
  notOccEmpty : ‚àÄ{b} ‚Üí NotOccupied b []
  notOccStep : ‚àÄ{b sq sqs}
    ‚Üí ¬¨ Occupied b sq
    ‚Üí NotOccupied b sqs
    ‚Üí NotOccupied b (sq ‚à∑ sqs)

data NotOccupiedSCastle : BoardArrangement ‚Üí Set where
  notOccSCastleW : ‚àÄ{b}
    ‚Üí (whosTurn b ‚â° white)
    ‚Üí ¬¨ Occupied b (G , #1)
    ‚Üí ¬¨ Occupied b (F , #1)
    ‚Üí NotOccupiedSCastle b

  notOccSCastleB : ‚àÄ{b}
    ‚Üí (whosTurn b ‚â° black)
    ‚Üí ¬¨ Occupied b (G , #8)
    ‚Üí ¬¨ Occupied b (F , #8)
    ‚Üí NotOccupiedSCastle b

data NotOccupiedLCastle : BoardArrangement ‚Üí Set where
  notOccLCastleW : ‚àÄ{b}
    ‚Üí (whosTurn b ‚â° white)
    ‚Üí ¬¨ Occupied b (B , #1)
    ‚Üí ¬¨ Occupied b (C , #1)
    ‚Üí ¬¨ Occupied b (D , #1)
    ‚Üí NotOccupiedLCastle b

  notOccLCastleB : ‚àÄ{b}
    ‚Üí (whosTurn b ‚â° black)
    ‚Üí ¬¨ Occupied b (B , #8)
    ‚Üí ¬¨ Occupied b (C , #8)
    ‚Üí ¬¨ Occupied b (D , #8)
    ‚Üí NotOccupiedLCastle b

-- sq is start, sq‚ÇÅ is dest, sq‚ÇÇ is opponent pawn
data IsEnPassantMove : BoardArrangement ‚Üí Square ‚Üí Square ‚Üí Square ‚Üí Set where
  isEnPassantMoveW : ‚àÄ{whichp b sq sq‚ÇÅ sq‚ÇÇ}
    ‚Üí T (rankEq #5 (proj‚ÇÇ sq))
    ‚Üí OccupiedWithOpponentPiece b (pawn whichp) sq‚ÇÇ
    ‚Üí T (fileEq (proj‚ÇÅ sq‚ÇÅ) (proj‚ÇÅ sq‚ÇÇ))
    ‚Üí T (oneRankHigher sq‚ÇÅ sq‚ÇÇ)
    ‚Üí IsEnPassantMove b sq sq‚ÇÅ sq‚ÇÇ

  isEnPassantMoveB : ‚àÄ{whichp b sq sq‚ÇÅ sq‚ÇÇ}
    ‚Üí T (rankEq #4 (proj‚ÇÇ sq))
    ‚Üí OccupiedWithOpponentPiece b (pawn whichp) sq‚ÇÇ
    ‚Üí T (fileEq (proj‚ÇÅ sq‚ÇÅ) (proj‚ÇÅ sq‚ÇÇ))
    ‚Üí T (oneRankLower sq‚ÇÅ sq‚ÇÇ)
    ‚Üí IsEnPassantMove b sq sq‚ÇÅ sq‚ÇÇ

-- | kings and their being in check

data CanBeAttacked : BoardArrangement ‚Üí Square ‚Üí Set where
  canAttackKing : ‚àÄ{b sq ksq}
    ‚Üí OccupiedWithOpponentPiece b king ksq
    ‚Üí T (oneSquareAway sq ksq)
    ‚Üí CanBeAttacked b sq

  canAttackQueenStraight : ‚àÄ{b sq qsq}
    ‚Üí OccupiedWithOpponentPiece b queen qsq
    ‚Üí (p : T (isStraight sq qsq))
    ‚Üí NotOccupied b (enumStraight sq qsq p)
    ‚Üí CanBeAttacked b sq
    
  canAttackQueenDiagonal : ‚àÄ{b sq qsq}
    ‚Üí OccupiedWithOpponentPiece b queen qsq
    ‚Üí (p : T (isDiagonal sq qsq))
    ‚Üí NotOccupied b (enumDiagonal sq qsq p)
    ‚Üí CanBeAttacked b sq

  canAttackBishop : ‚àÄ{whichb b sq bsq }
    ‚Üí OccupiedWithOpponentPiece b (bishop whichb) bsq
    ‚Üí (p : T (isDiagonal sq bsq))
    ‚Üí NotOccupied b (enumDiagonal sq bsq p)
    ‚Üí CanBeAttacked b sq

  canAttackKnight : ‚àÄ{whichk b sq ksq}
    ‚Üí OccupiedWithOpponentPiece b (knight whichk) ksq
    ‚Üí T (isHorseyMove sq ksq)
    ‚Üí CanBeAttacked b sq

  canAttackRook : ‚àÄ{whichr b sq rsq}
    ‚Üí OccupiedWithOpponentPiece b (rook whichr) rsq
    ‚Üí (p : T (isStraight sq rsq))
    ‚Üí NotOccupied b (enumStraight sq rsq p)
    ‚Üí CanBeAttacked b sq

  canAttackPawn : ‚àÄ{whichp b sq psq}
    ‚Üí OccupiedWithOpponentPiece b (pawn whichp) psq
    ‚Üí T (isCaptureMove b sq psq)
    ‚Üí CanBeAttacked b sq

data Check : BoardArrangement ‚Üí Set where
  check : ‚àÄ{b sq}
    ‚Üí OccupiedWith b king sq
    ‚Üí CanBeAttacked b sq
    ‚Üí Check b

data BadSquare : BoardArrangement ‚Üí Square ‚Üí Set where
  attackIsBad : ‚àÄ{b sq}
   ‚Üí CanBeAttacked b sq
   ‚Üí BadSquare b sq

  occFriendlyIsBad : ‚àÄ{b sq}
    ‚Üí OccupiedByFriendly b sq
    ‚Üí BadSquare b sq

data Checkmate : BoardArrangement ‚Üí Set where
  checkmate : ‚àÄ{b sq}
    ‚Üí OccupiedWith b king sq
    ‚Üí CanBeAttacked b sq
    ‚Üí All (BadSquare b) (sqsAround sq)
    ‚Üí Checkmate b

-- pseudo algebraic notation for moves

data Move : Set where
  0-0-0 : Move
  0-0 : Move
  ep : WhichPawn ‚Üí Square ‚Üí Move
  p= : WhichPawn ‚Üí Piece ‚Üí Move
  K : Square ‚Üí Move
  Q : Square ‚Üí Move
  B : Which ‚Üí Square ‚Üí Move
  R : Which ‚Üí Square ‚Üí Move
  N : Which ‚Üí Square ‚Üí Move
  P : WhichPawn ‚Üí Square ‚Üí Move
  Kx : Square ‚Üí Move
  Qx : Square ‚Üí Move
  Bx : Which ‚Üí Square ‚Üí Move
  Rx : Which ‚Üí Square ‚Üí Move
  Nx : Which ‚Üí Square ‚Üí Move
  Px : WhichPawn ‚Üí Square ‚Üí Move
  
-- | The Moves

-- the second board is the result of the move on the first board 
-- or at least that was the intention
-- according to the Game type b is the next board and b‚ÇÅ is the
-- old board. I don't understand why the Game type doesn't behave
-- intuitively
data IsMove : Move ‚Üí BoardArrangement ‚Üí BoardArrangement ‚Üí Set where
  mvKing : ‚àÄ{m b‚ÇÅ sq sq‚ÇÅ}
    ‚Üí (K sq‚ÇÅ) ‚â° m
    ‚Üí (b : BoardArrangement)
    ‚Üí ¬¨ Checkmate b
    ‚Üí OccupiedWith b king sq
    ‚Üí T (oneSquareAway sq sq‚ÇÅ)
    ‚Üí ¬¨ Occupied b sq‚ÇÅ
    ‚Üí b‚ÇÅ ‚â° markKingMoved (mvPiece b king sq‚ÇÅ)
    ‚Üí ¬¨ Check b‚ÇÅ
    ‚Üí IsMove m b b‚ÇÅ

  capKing : ‚àÄ{m b‚ÇÅ sq sq‚ÇÅ}
    ‚Üí (Kx sq‚ÇÅ) ‚â° m
    ‚Üí (b : BoardArrangement)
    ‚Üí ¬¨ Checkmate b
    ‚Üí OccupiedWith b king sq
    ‚Üí T (oneSquareAway sq sq‚ÇÅ)
    ‚Üí OccupiedByOpponent b sq‚ÇÅ
    ‚Üí b‚ÇÅ ‚â° capturePiece b king sq‚ÇÅ
    ‚Üí ¬¨ Check b‚ÇÅ
    ‚Üí IsMove m b b‚ÇÅ

  longCastle : ‚àÄ{b‚ÇÅ m}
    ‚Üí 0-0-0 ‚â° m
    ‚Üí (b : BoardArrangement)
    ‚Üí ¬¨ Checkmate b
    ‚Üí ¬¨ T (kMoved (turnSide b))
    ‚Üí ¬¨ T (qrMoved (turnSide b))
    ‚Üí ¬¨ (CanBeAttacked b (lcastlePassesThroughSquare b))
    ‚Üí NotOccupiedLCastle b 
    ‚Üí b‚ÇÅ ‚â° lcastle b
    ‚Üí ¬¨ Check b‚ÇÅ
    ‚Üí IsMove 0-0-0 b b‚ÇÅ

  shortCastle : ‚àÄ{b‚ÇÅ m}
    ‚Üí 0-0 ‚â° m
    ‚Üí (b : BoardArrangement)
    ‚Üí ¬¨ Checkmate b
    ‚Üí ¬¨ T (kMoved (turnSide b))
    ‚Üí ¬¨ T (krMoved (turnSide b))
    ‚Üí ¬¨ CanBeAttacked b (scastlePassesThroughSquare b)
    ‚Üí NotOccupiedSCastle b
    ‚Üí b‚ÇÅ ‚â° scastle b
    ‚Üí ¬¨ Check b‚ÇÅ
    ‚Üí IsMove 0-0 b b‚ÇÅ
    
  mvQueenStraight : ‚àÄ{b‚ÇÅ sq sq‚ÇÅ m}
    ‚Üí (Q sq‚ÇÅ) ‚â° m
    ‚Üí (b : BoardArrangement)
    ‚Üí ¬¨ Check b
    ‚Üí OccupiedWith b queen sq
    ‚Üí (p : T (isStraight sq sq‚ÇÅ))
    ‚Üí NotOccupied b (enumStraight sq sq‚ÇÅ p)
    ‚Üí ¬¨ Occupied b sq‚ÇÅ
    ‚Üí b‚ÇÅ ‚â° mvPiece b queen sq‚ÇÅ
    ‚Üí ¬¨ Check b‚ÇÅ
    ‚Üí IsMove m b b‚ÇÅ

  capQueenStraight : ‚àÄ{b‚ÇÅ m sq sq‚ÇÅ}
    ‚Üí (Qx sq‚ÇÅ) ‚â° m
    ‚Üí (b : BoardArrangement)
    ‚Üí ¬¨ Check b
    ‚Üí OccupiedWith b queen sq
    ‚Üí (p : T (isStraight sq sq‚ÇÅ))
    ‚Üí NotOccupied b (enumStraight sq sq‚ÇÅ p)
    ‚Üí OccupiedByOpponent b sq‚ÇÅ
    ‚Üí b‚ÇÅ ‚â° capturePiece b queen sq‚ÇÅ
    ‚Üí ¬¨ Check b‚ÇÅ
    ‚Üí IsMove m b b‚ÇÅ

  mvQueenDiagonal : ‚àÄ{b‚ÇÅ m sq sq‚ÇÅ}
    ‚Üí (Q sq‚ÇÅ) ‚â° m
    ‚Üí (b : BoardArrangement)
    ‚Üí ¬¨ Check b
    ‚Üí OccupiedWith b queen sq
    ‚Üí (p : T (isDiagonal sq sq‚ÇÅ))
    ‚Üí NotOccupied b (enumDiagonal sq sq‚ÇÅ p)
    ‚Üí ¬¨ Occupied b sq‚ÇÅ
    ‚Üí b‚ÇÅ ‚â° mvPiece b queen sq‚ÇÅ
    ‚Üí ¬¨ Check b‚ÇÅ
    ‚Üí IsMove m b b‚ÇÅ

  capQueenDiagonal : ‚àÄ{b‚ÇÅ m sq sq‚ÇÅ}
    ‚Üí (Qx sq‚ÇÅ) ‚â° m
    ‚Üí (b : BoardArrangement)
    ‚Üí ¬¨ Check b
    ‚Üí OccupiedWith b queen sq
    ‚Üí (p : T (isDiagonal sq sq‚ÇÅ))
    ‚Üí NotOccupied b (enumDiagonal sq sq‚ÇÅ p) 
    ‚Üí OccupiedByOpponent b sq‚ÇÅ
    ‚Üí b‚ÇÅ ‚â° capturePiece b queen sq‚ÇÅ
    ‚Üí ¬¨ Check b‚ÇÅ
    ‚Üí IsMove m b b‚ÇÅ
    
  mvBishop : ‚àÄ{b‚ÇÅ sq m whichb sq‚ÇÅ}
    ‚Üí (B whichb sq) ‚â° m
    ‚Üí (b : BoardArrangement)
    ‚Üí ¬¨ Check b
    ‚Üí OccupiedWith b (bishop whichb) sq
    ‚Üí (p : T (isDiagonal sq sq‚ÇÅ))
    ‚Üí NotOccupied b (enumDiagonal sq sq‚ÇÅ p)
    ‚Üí ¬¨ Occupied b sq‚ÇÅ
    ‚Üí b‚ÇÅ ‚â° mvPiece b (bishop whichb) sq‚ÇÅ
    ‚Üí ¬¨ Check b‚ÇÅ
    ‚Üí IsMove m b b‚ÇÅ

  capBishop : ‚àÄ{b‚ÇÅ sq m whichb sq‚ÇÅ}
    ‚Üí (Bx whichb sq) ‚â° m
    ‚Üí (b : BoardArrangement)
    ‚Üí ¬¨ Check b
    ‚Üí OccupiedWith b (bishop whichb) sq
    ‚Üí (p : T (isDiagonal sq sq‚ÇÅ))
    ‚Üí NotOccupied b (enumDiagonal sq sq‚ÇÅ p)
    ‚Üí OccupiedByOpponent b sq‚ÇÅ
    ‚Üí b‚ÇÅ ‚â° capturePiece b (bishop whichb) sq‚ÇÅ
    ‚Üí ¬¨ Check b‚ÇÅ
    ‚Üí IsMove m b b‚ÇÅ

  mvKnight : ‚àÄ{b‚ÇÅ sq sq‚ÇÅ m whichk}
    ‚Üí (N whichk sq‚ÇÅ) ‚â° m
    ‚Üí (b : BoardArrangement)
    ‚Üí ¬¨ Check b
    ‚Üí OccupiedWith b (knight whichk) sq
    ‚Üí T (isHorseyMove sq sq‚ÇÅ)
    ‚Üí ¬¨ Occupied b sq‚ÇÅ
    ‚Üí b‚ÇÅ ‚â° mvPiece b (knight whichk) sq‚ÇÅ
    ‚Üí ¬¨ Check b‚ÇÅ
    ‚Üí IsMove m b b‚ÇÅ

  capKnight : ‚àÄ{b‚ÇÅ sq m sq‚ÇÅ whichk}
    ‚Üí (Nx whichk sq‚ÇÅ) ‚â° m
    ‚Üí (b : BoardArrangement)
    ‚Üí ¬¨ Check b
    ‚Üí OccupiedWith b (knight whichk) sq
    ‚Üí T (isHorseyMove sq sq‚ÇÅ)
    ‚Üí OccupiedByOpponent b sq‚ÇÅ
    ‚Üí b‚ÇÅ ‚â° capturePiece b (knight whichk) sq‚ÇÅ
    ‚Üí ¬¨ Check b‚ÇÅ
    ‚Üí IsMove m b b‚ÇÅ

  mvRook : ‚àÄ{b‚ÇÅ sq m sq‚ÇÅ whichr}
    ‚Üí (R whichr sq‚ÇÅ) ‚â° m
    ‚Üí (b : BoardArrangement)
    ‚Üí ¬¨ Check b
    ‚Üí OccupiedWith b (rook whichr) sq
    ‚Üí (p : T (isStraight sq sq‚ÇÅ))
    ‚Üí NotOccupied b (enumStraight sq sq‚ÇÅ p) 
    ‚Üí ¬¨ Occupied b sq‚ÇÅ
    ‚Üí b‚ÇÅ ‚â° markRookMoved whichr (mvPiece b (rook whichr) sq‚ÇÅ)
    ‚Üí ¬¨ Check b‚ÇÅ
    ‚Üí IsMove m b b‚ÇÅ

  capRook : ‚àÄ{b‚ÇÅ sq m sq‚ÇÅ whichr}
    ‚Üí (Rx whichr sq‚ÇÅ) ‚â° m
    ‚Üí (b : BoardArrangement)
    ‚Üí ¬¨ Check b
    ‚Üí OccupiedWith b (rook whichr) sq
    ‚Üí (p : T (isStraight sq sq‚ÇÅ))
    ‚Üí NotOccupied b (enumStraight sq sq‚ÇÅ p) 
    ‚Üí OccupiedByOpponent b sq‚ÇÅ
    ‚Üí b‚ÇÅ ‚â° markRookMoved whichr (mvPiece b (rook whichr) sq‚ÇÅ)
    ‚Üí ¬¨ Check b‚ÇÅ
    ‚Üí IsMove m b b‚ÇÅ

  mvPawn : ‚àÄ{b‚ÇÅ sq m sq‚ÇÅ whichp}
    ‚Üí (P whichp sq‚ÇÅ) ‚â° m
    ‚Üí (b : BoardArrangement)
    ‚Üí ¬¨ Check b
    ‚Üí OccupiedWith b (pawn whichp) sq
    ‚Üí NotPromoted b whichp
    ‚Üí T (oneSquareForward b sq‚ÇÅ sq)
    ‚Üí ¬¨ Occupied b sq‚ÇÅ
    ‚Üí b‚ÇÅ ‚â° movePawn b whichp sq‚ÇÅ
    ‚Üí ¬¨ Check b‚ÇÅ
    ‚Üí IsMove m b‚ÇÅ b

  capPawn : ‚àÄ{b‚ÇÅ sq m sq‚ÇÅ whichp}
    ‚Üí (Px whichp sq‚ÇÅ) ‚â° m
    ‚Üí (b : BoardArrangement)
    ‚Üí ¬¨ Check b
    ‚Üí OccupiedWith b (pawn whichp) sq
    ‚Üí NotPromoted b whichp
    ‚Üí T (isCaptureMove b sq sq‚ÇÅ)
    ‚Üí OccupiedByOpponent b sq‚ÇÅ
    ‚Üí b‚ÇÅ ‚â° capturePawn b whichp sq‚ÇÅ
    ‚Üí ¬¨ Check b‚ÇÅ
    ‚Üí IsMove m b b‚ÇÅ

  enPassant : ‚àÄ{b‚ÇÅ sq m sq‚ÇÅ sq‚ÇÇ whichp}
    ‚Üí (ep whichp sq‚ÇÅ) ‚â° m
    ‚Üí (b : BoardArrangement)
    ‚Üí ¬¨ Check b
    ‚Üí ¬¨ T (pawnMoved b whichp)
    ‚Üí OccupiedWith b (pawn whichp) sq
    ‚Üí IsEnPassantMove b sq sq‚ÇÅ sq‚ÇÇ
    ‚Üí b‚ÇÅ ‚â° doEnPassant b whichp sq‚ÇÅ sq‚ÇÇ
    ‚Üí ¬¨ Check b‚ÇÅ
    ‚Üí IsMove m b b‚ÇÅ

  promote : ‚àÄ{b‚ÇÅ sq whichp p m}
    ‚Üí (p= whichp p) ‚â° m
    ‚Üí (b : BoardArrangement)
    ‚Üí ¬¨ Check b
    ‚Üí OccupiedWith b (pawn whichp) sq
    ‚Üí NotPromoted b whichp
    ‚Üí T (atTopOrBottom sq)
    ‚Üí b‚ÇÅ ‚â° promotePawn b whichp p
    ‚Üí IsMove m b b‚ÇÅ

  mvPromotedKnight : ‚àÄ{b‚ÇÅ sq whichk whichp m sq‚ÇÅ}
    ‚Üí (P whichp sq‚ÇÅ) ‚â° m
    ‚Üí (b : BoardArrangement)
    ‚Üí ¬¨ Check b
    ‚Üí OccupiedWith b (pawn whichp) sq
    ‚Üí Promoted b whichp (knight whichk)
    ‚Üí T (isHorseyMove sq sq‚ÇÅ)
    ‚Üí ¬¨ Occupied b sq‚ÇÅ
    ‚Üí b‚ÇÅ ‚â° mvPiece b (pawn whichp) sq‚ÇÅ
    ‚Üí ¬¨ Check b‚ÇÅ
    ‚Üí IsMove m b b‚ÇÅ

  capPromotedKnight : ‚àÄ{b‚ÇÅ sq whichk whichp m sq‚ÇÅ}
    ‚Üí (Px whichp sq‚ÇÅ) ‚â° m
    ‚Üí (b : BoardArrangement)
    ‚Üí ¬¨ Check b
    ‚Üí OccupiedWith b (pawn whichp) sq
    ‚Üí Promoted b whichp (knight whichk)
    ‚Üí T (isHorseyMove sq sq‚ÇÅ)
    ‚Üí OccupiedByOpponent b sq‚ÇÅ
    ‚Üí b‚ÇÅ ‚â° capturePiece b (pawn whichp) sq‚ÇÅ
    ‚Üí ¬¨ Check b‚ÇÅ
    ‚Üí IsMove m b b‚ÇÅ

  mvPromotedQueenStraight : ‚àÄ{b‚ÇÅ sq whichp m sq‚ÇÅ}
    ‚Üí (P whichp sq‚ÇÅ) ‚â° m
    ‚Üí (b : BoardArrangement)
    ‚Üí ¬¨ Check b
    ‚Üí OccupiedWith b queen sq
    ‚Üí Promoted b whichp queen
    ‚Üí (p : T (isStraight sq sq‚ÇÅ))
    ‚Üí NotOccupied b (enumStraight sq sq‚ÇÅ p)
    ‚Üí ¬¨ Occupied b sq‚ÇÅ
    ‚Üí b‚ÇÅ ‚â° mvPiece b (pawn whichp) sq‚ÇÅ
    ‚Üí ¬¨ Check b‚ÇÅ
    ‚Üí IsMove m b b‚ÇÅ

  capPromotedQueenStraight : ‚àÄ{b‚ÇÅ sq m whichp sq‚ÇÅ}
    ‚Üí (Px whichp sq‚ÇÅ) ‚â° m
    ‚Üí (b : BoardArrangement)
    ‚Üí ¬¨ Check b
    ‚Üí OccupiedWith b (pawn whichp) sq
    ‚Üí Promoted b whichp queen
    ‚Üí (p : T (isStraight sq sq‚ÇÅ))
    ‚Üí NotOccupied b (enumStraight sq sq‚ÇÅ p)
    ‚Üí OccupiedByOpponent b sq‚ÇÅ
    ‚Üí b‚ÇÅ ‚â° capturePiece b (pawn whichp) sq‚ÇÅ
    ‚Üí ¬¨ Check b‚ÇÅ
    ‚Üí IsMove m b b‚ÇÅ

  mvPromotedQueenDiagonal : ‚àÄ{b‚ÇÅ sq m whichp sq‚ÇÅ}
    ‚Üí (P whichp sq‚ÇÅ) ‚â° m
    ‚Üí (b : BoardArrangement)
    ‚Üí ¬¨ Check b
    ‚Üí OccupiedWith b (pawn whichp) sq
    ‚Üí Promoted b whichp queen
    ‚Üí (p : T (isDiagonal sq sq‚ÇÅ))
    ‚Üí NotOccupied b (enumDiagonal sq sq‚ÇÅ p)
    ‚Üí ¬¨ Occupied b sq‚ÇÅ
    ‚Üí b‚ÇÅ ‚â° mvPiece b (pawn whichp) sq‚ÇÅ
    ‚Üí ¬¨ Check b‚ÇÅ
    ‚Üí IsMove m b b‚ÇÅ

  capPromotedQueenDiagonal : ‚àÄ{b‚ÇÅ sq whichp m sq‚ÇÅ}
    ‚Üí (Px whichp sq‚ÇÅ) ‚â° m
    ‚Üí (b : BoardArrangement)
    ‚Üí ¬¨ Check b
    ‚Üí OccupiedWith b (pawn whichp) sq
    ‚Üí Promoted b whichp queen
    ‚Üí (p : T (isDiagonal sq sq‚ÇÅ))
    ‚Üí NotOccupied b (enumDiagonal sq sq‚ÇÅ p)
    ‚Üí OccupiedByOpponent b sq‚ÇÅ
    ‚Üí b‚ÇÅ ‚â° capturePiece b (pawn whichp) sq‚ÇÅ
    ‚Üí ¬¨ Check b‚ÇÅ
    ‚Üí IsMove m b b‚ÇÅ

  -- i don't feel like adding rules for every possible promotion
  -- the queen and knight should give you all the flexibility you
  -- need

data Game : List Move ‚Üí BoardArrangement ‚Üí Set where
  gameEnd : ‚àÄ{b} ‚Üí Game [] b
  game : ‚àÄ{m ms b b‚ÇÅ} ‚Üí IsMove m b‚ÇÅ b ‚Üí Game ms b‚ÇÅ ‚Üí Game (m ‚à∑ ms) b

initialBoard : BoardArrangement
initialBoard =
  let s = record {
        kMoved = false
       ; qrMoved = false
       ; krMoved = false
       ; pawnHasMoved = (p1 , false)
                     ‚à∑ (p2 , false)
                     ‚à∑ (p3 , false)
                     ‚à∑ (p4 , false)
                     ‚à∑ (p5 , false)
                     ‚à∑ (p6 , false)
                     ‚à∑ (p7 , false)
                     ‚à∑ (p8 , false)
                     ‚à∑ []
       ; pawnPromotes = (p1 , nothing)
                     ‚à∑ (p2 , nothing)
                     ‚à∑ (p3 , nothing)
                     ‚à∑ (p4 , nothing)
                     ‚à∑ (p5 , nothing)
                     ‚à∑ (p6 , nothing)
                     ‚à∑ (p7 , nothing)
                     ‚à∑ (p8 , nothing)
                     ‚à∑ []
       ; pieces = []
        }
      ws = record s { pieces =
               (rook q   , just (A , #1))
             ‚à∑ (knight q , just (B , #1))
             ‚à∑ (bishop q , just (C , #1))
             ‚à∑ (queen         , just (D , #1))
             ‚à∑ (king          , just (E , #1))
             ‚à∑ (bishop k  , just (F , #1))
             ‚à∑ (knight k  , just (G , #1))
             ‚à∑ (rook k    , just (H , #1))
             ‚à∑ (pawn p1 , just (A , #2))
             ‚à∑ (pawn p2 , just (B , #2))
             ‚à∑ (pawn p3 , just (C , #2))
             ‚à∑ (pawn p4 , just (D , #2))
             ‚à∑ (pawn p5 , just (E , #2))
             ‚à∑ (pawn p6 , just (F , #2))
             ‚à∑ (pawn p7 , just (G , #2))
             ‚à∑ (pawn p8 , just (H , #2))
             ‚à∑ []
           }

      bs = record s { pieces =
               (rook q   , just (A , #8))
             ‚à∑ (knight q , just (B , #8))
             ‚à∑ (bishop q , just (C , #8))
             ‚à∑ (queen         , just (D , #8))
             ‚à∑ (king          , just (E , #8))
             ‚à∑ (bishop k  , just (F , #8))
             ‚à∑ (knight k  , just (G , #8))
             ‚à∑ (rook k    , just (H , #8))
             ‚à∑ (pawn p1 , just (A , #7))
             ‚à∑ (pawn p2 , just (B , #7))
             ‚à∑ (pawn p3 , just (C , #7))
             ‚à∑ (pawn p4 , just (D , #7))
             ‚à∑ (pawn p5 , just (E , #7))
             ‚à∑ (pawn p6 , just (F , #7))
             ‚à∑ (pawn p7 , just (G , #7))
             ‚à∑ (pawn p8 , just (H , #7))
             ‚à∑ [] }
  in record { whosTurn = white
            ; whiteSide = ws
            ; blackSide = bs
            }

b1 : ‚àÄ{whichb} ‚Üí bishop whichb ‚â° bishop whichb
b1 = refl

-- holy cow it takes a lot to see that the initial board is not in check
notCheckInitialBoard : ¬¨ Check initialBoard
notCheckInitialBoard (check (occWith refl) (canAttackKing (occWithOpponentPiece refl) ()))
notCheckInitialBoard (check (occWith refl) (canAttackQueenStraight (occWithOpponentPiece refl) p x‚ÇÅ)) = p
notCheckInitialBoard (check (occWith refl) (canAttackQueenDiagonal (occWithOpponentPiece refl) p x‚ÇÅ)) = p
notCheckInitialBoard (check (occWith refl) (canAttackBishop {k} (occWithOpponentPiece refl) p x‚ÇÅ)) = p
notCheckInitialBoard (check (occWith refl) (canAttackBishop {q} (occWithOpponentPiece refl) p x‚ÇÅ)) = p
notCheckInitialBoard (check (occWith refl) (canAttackKnight {k} (occWithOpponentPiece refl) ()))
notCheckInitialBoard (check (occWith refl) (canAttackKnight {q} (occWithOpponentPiece refl) x‚ÇÅ)) = x‚ÇÅ
notCheckInitialBoard (check (occWith refl) (canAttackRook {k} (occWithOpponentPiece refl) p (notOccStep x x‚ÇÅ))) = p
notCheckInitialBoard (check (occWith refl) (canAttackRook {q} (occWithOpponentPiece refl) p x‚ÇÅ)) = p
notCheckInitialBoard (check (occWith refl) (canAttackPawn {p1} (occWithOpponentPiece refl) x‚ÇÅ)) = x‚ÇÅ
notCheckInitialBoard (check (occWith refl) (canAttackPawn {p2} (occWithOpponentPiece refl) x‚ÇÅ)) = x‚ÇÅ
notCheckInitialBoard (check (occWith refl) (canAttackPawn {p3} (occWithOpponentPiece refl) x‚ÇÅ)) = x‚ÇÅ
notCheckInitialBoard (check (occWith refl) (canAttackPawn {p4} (occWithOpponentPiece refl) x‚ÇÅ)) = x‚ÇÅ
notCheckInitialBoard (check (occWith refl) (canAttackPawn {p5} (occWithOpponentPiece refl) x‚ÇÅ)) = x‚ÇÅ
notCheckInitialBoard (check (occWith refl) (canAttackPawn {p6} (occWithOpponentPiece refl) x‚ÇÅ)) = x‚ÇÅ
notCheckInitialBoard (check (occWith refl) (canAttackPawn {p7} (occWithOpponentPiece refl) x‚ÇÅ)) = x‚ÇÅ
notCheckInitialBoard (check (occWith refl) (canAttackPawn {p8} (occWithOpponentPiece refl) x‚ÇÅ)) = x‚ÇÅ

cb : Game [] initialBoard
cb = gameEnd

-- we have to go through 16*2 pieces
notOccD3 : ¬¨ Occupied initialBoard (D , #3)
notOccD3 (occupied (next (next (next (next (next (next (next (next (next (next (next (next (next (next (next (next (next (next (next (next (next (next (next (next (next (next (next (next (next (next (next (next ())))))))))))))))))))))))))))))))))

-- same as notCheckInitialBoard
notCheckMoveP4 : ¬¨ Check (movePawn initialBoard p4 (D , #3))
notCheckMoveP4 (check (occWith refl) (canAttackKing (occWithOpponentPiece refl) ()))
notCheckMoveP4 (check (occWith refl) (canAttackQueenStraight (occWithOpponentPiece refl) p x‚ÇÅ)) = p
notCheckMoveP4 (check (occWith refl) (canAttackQueenDiagonal (occWithOpponentPiece refl) p x‚ÇÅ)) = p
notCheckMoveP4 (check (occWith refl) (canAttackBishop {k} (occWithOpponentPiece refl) p x‚ÇÅ)) = p
notCheckMoveP4 (check (occWith refl) (canAttackBishop {q} (occWithOpponentPiece refl) p x‚ÇÅ)) = p
notCheckMoveP4 (check (occWith refl) (canAttackKnight {k} (occWithOpponentPiece refl) ()))
notCheckMoveP4 (check (occWith refl) (canAttackKnight {q} (occWithOpponentPiece refl) x‚ÇÅ)) = x‚ÇÅ
notCheckMoveP4 (check (occWith refl) (canAttackRook {k} (occWithOpponentPiece refl) p (notOccStep x x‚ÇÅ))) = p
notCheckMoveP4 (check (occWith refl) (canAttackRook {q} (occWithOpponentPiece refl) p x‚ÇÅ)) = p
notCheckMoveP4 (check (occWith refl) (canAttackPawn {p1} (occWithOpponentPiece refl) x‚ÇÅ)) = x‚ÇÅ
notCheckMoveP4 (check (occWith refl) (canAttackPawn {p2} (occWithOpponentPiece refl) x‚ÇÅ)) = x‚ÇÅ
notCheckMoveP4 (check (occWith refl) (canAttackPawn {p3} (occWithOpponentPiece refl) x‚ÇÅ)) = x‚ÇÅ
notCheckMoveP4 (check (occWith refl) (canAttackPawn {p4} (occWithOpponentPiece refl) x‚ÇÅ)) = x‚ÇÅ
notCheckMoveP4 (check (occWith refl) (canAttackPawn {p5} (occWithOpponentPiece refl) x‚ÇÅ)) = x‚ÇÅ
notCheckMoveP4 (check (occWith refl) (canAttackPawn {p6} (occWithOpponentPiece refl) x‚ÇÅ)) = x‚ÇÅ
notCheckMoveP4 (check (occWith refl) (canAttackPawn {p7} (occWithOpponentPiece refl) x‚ÇÅ)) = x‚ÇÅ
notCheckMoveP4 (check (occWith refl) (canAttackPawn {p8} (occWithOpponentPiece refl) x‚ÇÅ)) = x‚ÇÅ

ca : Game (P p4 (D , #3)
          ‚à∑ [])
          initialBoard
ca = game (mvPawn refl initialBoard (notCheckInitialBoard) (occWith refl) (isNotPromotedW refl (Any.there
                                                                                                  (Any.there (Any.there (Any.here (isNotProm refl refl)))))) tt notOccD3 refl notCheckMoveP4) gameEnd
